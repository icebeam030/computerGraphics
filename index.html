<!DOCTYPE html>
<html lang="en">

<head>
	<title>Shooting Game</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="css/main.css">

</head>

<body>

	<div id="info">Press "W" "S" "A" "D" to control object.<br />
		"c":crouch, "ctrl":attack, "space":jump
	</div>
	<div id="container"><br /><br /><br /><br /><br />Loading...</div>

	<script src="js/three.js"></script>
	<script src="js/libs/ammo.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/WebGL.js"></script>
	<script src="js/libs/stats.min.js"></script>
	<script src="js/ConvexObjectBreaker.js"></script>
	<script src="js/QuickHull.js"></script>
	<script src="js/geometries/ConvexGeometry.js"></script>
	<script src="js/libs/inflate.min.js"></script>
	<script src="js/loaders/FBXLoader.js"></script>
	<script src="js/loaders/GLTFLoader.js"></script>
	<script src="js/libs/dat.gui.min.js"></script>
	<script src="js/loaders/MD2Loader.js"></script>
	<script src="js/MorphBlendMesh.js"></script>
	<script src="js/MD2CharacterComplex.js"></script>
	<script src="js/Gyroscope.js"></script>
	<script src="js/InputEvent.js"></script>
	<script src="js/light.js"></script>
	<script src="js/physics.js"></script>
	<script scr="js/dat.gui.js"></script>

	<script>
		// Detects webgl
		if (WEBGL.isWebGLAvailable() === false) {
			document.body.appendChild(WEBGL.getWebGLErrorMessage());
			document.getElementById('container').innerHTML = "";
		}

		// - Global variables -
		var characters = [];
		var nCharacters = 0;

		// Graphics variables
		var container, stats;
		var camera, cameraControls, scene, renderer;
		
		var textureLoader;
		var clock = new THREE.Clock();

		// Physics variables
		var gravityConstant = 7.8;
		var collisionConfiguration;
		var dispatcher;
		var broadphase;
		var solver;
		var physicsWorld;
		var margin = 0.01;

		var convexBreaker = new THREE.ConvexObjectBreaker();

		// Rigid bodies include all movable objects
		var rigidBodies = [];

		var pos = new THREE.Vector3();
		var quat = new THREE.Quaternion();
		var transformAux1 = new Ammo.btTransform();
		var tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

		var time = 0;

		var objectsToRemove = [];
		for (var i = 0; i < 500; i++) {
			objectsToRemove[i] = null;
		}
		var numObjectsToRemove = 0;

		var impactPoint = new THREE.Vector3();
		var impactNormal = new THREE.Vector3();

		//ymq
		var controls = {

			moveForward: false,
			moveBackward: false,
			moveLeft: false,
			moveRight: false

		};

		var prevTime = performance.now();
		var velocity = new THREE.Vector3();
		var direction = new THREE.Vector3();
		var humanObject = new THREE.Object3D();

		var pinBoundingBoxHelper;
		var characterBoundingBoxHelper;

		// Variables
		var ballVelocitySpeed = 10;
		var ballMass = 10;
		var ballRadius = 0.127;
		var ballMaterial = new THREE.MeshPhongMaterial({ color: 0x202020 });
		
		var ground;
		
		//var ballMeterial;
		//ballMeterial = new THREE.MeshPhongMaterial();
        //ballMeterial.color=new THREE.Color(1,1,0.4);		
		
		

		// - Main code -
		init();
		animate();

		// - Functions -
		function init() {
			initGraphics();
			initPhysics();
			createObjects();

			//////////////////////////////////
			loadObjects();
			initInput();
			/////////////////////////////////
			
			initControlPanel();
		}

		function loadObjects() {
			loadCharactoer();
			loadBowlingPin();
		}

		function initGraphics() {

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xbfd1e5);

			camera.position.set(-3, 9, -25);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			
			cameraControls = new THREE.OrbitControls(camera,renderer.domElement);
			cameraControls.target.set(0, 2, 0);
			cameraControls.update();

			textureLoader = new THREE.TextureLoader();

			addLight(scene);

			container.innerHTML = "";

			container.appendChild(renderer.domElement);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild(stats.domElement);

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}


		function animate() {

			requestAnimationFrame(animate);

			if (pinBoundingBoxHelper) {
				pinBoundingBoxHelper.update();
			}
			if (characterBoundingBoxHelper) {
				characterBoundingBoxHelper.update();
			}
			render();
			stats.update();
		}

		function render() {
			var deltaTime = clock.getDelta();
			for (var i = 0; i < nCharacters; i++) {

				characters[i].update(deltaTime);

			}
			updatePhysics(deltaTime);
			
			renderer.render(scene, camera);
			time += deltaTime;
		}

		function updatePhysics(deltaTime) {

			// Step world
			physicsWorld.stepSimulation(deltaTime, 10);

			// Update rigid bodies
			for (var i = 0, il = rigidBodies.length; i < il; i++) {
				var objThree = rigidBodies[i];
				var objPhys = objThree.userData.physicsBody;
				var ms = objPhys.getMotionState();
				if (ms) {

					ms.getWorldTransform(transformAux1);
					var p = transformAux1.getOrigin();
					var q = transformAux1.getRotation();
					objThree.position.set(p.x(), p.y(), p.z());
					objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

					objThree.userData.collided = false;

				}
			}

			for (var i = 0, il = dispatcher.getNumManifolds(); i < il; i++) {

				var contactManifold = dispatcher.getManifoldByIndexInternal(i);
				var rb0 = contactManifold.getBody0();
				var rb1 = contactManifold.getBody1();

				var threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
				var threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;

				if (!threeObject0 && !threeObject1) {
					continue;
				}

				var userData0 = threeObject0 ? threeObject0.userData : null;
				var userData1 = threeObject1 ? threeObject1.userData : null;

				var breakable0 = userData0 ? userData0.breakable : false;
				var breakable1 = userData1 ? userData1.breakable : false;

				var collided0 = userData0 ? userData0.collided : false;
				var collided1 = userData1 ? userData1.collided : false;

				if ((!breakable0 && !breakable1) || (collided0 && collided1)) {
					continue;
				}

				var contact = false;
				var maxImpulse = 0;
				for (var j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {
					var contactPoint = contactManifold.getContactPoint(j);
					if (contactPoint.getDistance() < 0) {
						contact = true;
						var impulse = contactPoint.getAppliedImpulse();
						if (impulse > maxImpulse) {
							maxImpulse = impulse;
							var pos = contactPoint.get_m_positionWorldOnB();
							var normal = contactPoint.get_m_normalWorldOnB();
							impactPoint.set(pos.x(), pos.y(), pos.z());
							impactNormal.set(normal.x(), normal.y(), normal.z());
						}
						break;
					}
				}

				// If no point has contact, abort
				if (!contact) {
					continue;
				}

				// Subdivision
				var fractureImpulse = 250;

				if (breakable0 && !collided0 && maxImpulse > fractureImpulse) {

					var debris = convexBreaker.subdivideByImpact(threeObject0, impactPoint, impactNormal, 1, 2, 1.5);

					var numObjects = debris.length;
					for (var j = 0; j < numObjects; j++) {
						createDebrisFromBreakableObject(debris[j]);
					}

					objectsToRemove[numObjectsToRemove++] = threeObject0;
					userData0.collided = true;

				}

				if (breakable1 && !collided1 && maxImpulse > fractureImpulse) {

					var debris = convexBreaker.subdivideByImpact(threeObject1, impactPoint, impactNormal, 1, 2, 1.5);
					var numObjects = debris.length;
					for (var j = 0; j < numObjects; j++) {
						createDebrisFromBreakableObject(debris[j]);
					}
					objectsToRemove[numObjectsToRemove++] = threeObject1;
					userData1.collided = true;
				}
			}
			for (var i = 0; i < numObjectsToRemove; i++) {
				removeDebris(objectsToRemove[i]);
			}
			numObjectsToRemove = 0;
		}



		function loadCharactoer() {
			var configOgro = {

				baseUrl: "models/md2/ogro/",

				body: "ogro.md2",
				skins: ["grok.jpg", "ogrobase.png", "arboshak.png", "ctf_r.png", "ctf_b.png", "darkam.png", "freedom.png",
					"gib.png", "gordogh.png", "igdosh.png", "khorne.png", "nabogro.png",
					"sharokh.png"],
				weapons: [["weapon.md2", "weapon.jpg"]],
				animations: {
					move: "run",
					idle: "stand",
					jump: "jump",
					attack: "attack",
					crouchMove: "cwalk",
					crouchIdle: "cstand",
					crouchAttach: "crattack"
				},

				walkSpeed: 3,
				crouchSpeed: 175

			};

			var nRows = 1;
			var nSkins = configOgro.skins.length;

			nCharacters = nSkins * nRows;
			for (var i = 0; i < nCharacters; i++) {

				var character = new THREE.MD2CharacterComplex();
				character.scale = 0.05;
				character.controls = controls;
				characters.push(character);
			}

			var baseCharacter = new THREE.MD2CharacterComplex();
			baseCharacter.scale = 0.05;
			baseCharacter.onLoadComplete = function () {

				var cloneCharacter = characters[0];
				cloneCharacter.shareParts(baseCharacter);
				// cast and receive shadows
				cloneCharacter.enableShadows(true);
				cloneCharacter.setWeapon(0);
				cloneCharacter.setSkin(5);

				humanObject = cloneCharacter.root;
				humanObject.translateZ(-15);

				characterBoundingBoxHelper = new THREE.BoxHelper(cloneCharacter.root, 0xff00f0);
				scene.add(characterBoundingBoxHelper);

				scene.add(cloneCharacter.root);
			};

			baseCharacter.loadParts(configOgro);


		}

		function loadBowlingPin() {
			var loader = new THREE.FBXLoader();
			loader.load('models/pin.fbx', function (bowlingPin) {

				bowlingPin.traverse(function (child) {

					if (child.isMesh) {

						child.castShadow = true;
						child.receiveShadow = true;

					}

				});

				bowlingPin.scale.set(9, 9, 9);

				var pinBoundingBox = new THREE.Box3().setFromObject(bowlingPin);;

				var wpVector = new THREE.Vector3();
				bowlingPin.getWorldPosition(wpVector);

				pos.copy(wpVector);
				quat.set(0, 0, 0, 1);

				var size = new THREE.Vector3();
				pinBoundingBox.getSize(size);

				var boxShape = new Ammo.btBoxShape(new Ammo.btVector3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
				boxShape.setMargin(margin);
				var pinMass = 1.5;
				var rigidBody = createRigidBody(bowlingPin, boxShape, pinMass, pos, quat);

				pinBoundingBoxHelper = new THREE.BoxHelper(bowlingPin, 0xff00f0);
				scene.add(pinBoundingBoxHelper);
				scene.add(bowlingPin);

			});
		}
		
		
		//---------------------------------------Control Panel-----------------------
		var path = "hardwood2_diffuse.jpg"
		var u = 15;
		var v = 15;
		
		
		function initControlPanel(){ 
			var setting = { 				
				BulletColor: ballMaterial.color.getHex(),
				BulletSpeed: ballVelocitySpeed,
				BulletSize: ballRadius,
				CharacterSkin : "grok",
				BulletMass: ballMass
				
			};
			var character = ["grok", "ogrobase", "arboshak", "ctf_r", "ctf_b", "darkam", "freedom",
					"gib", "gordogh", "igdosh", "khorne", "nabogro",
					"sharokh"];
			character.sort();
			var gui = new dat.GUI();
			
			var characterfolder = gui.addFolder('Character Folder');
			var ballcolor = characterfolder.addColor(setting, 'BulletColor').onChange( function (val) {
				ballMaterial.color.setHex(val);
			});
			var bulletspeed = characterfolder.add(setting,"BulletSpeed",1,100).onChange(function(val){
				ballVelocitySpeed = val;
			});
			var bulletsize = characterfolder.add(setting,"BulletSize",0.001,1).onChange(function(val){
				ballRadius = val;
			});
			var ballmasscon = characterfolder.add(setting, 'BulletMass',10,500).onChange(function(val){
				ballMass = val;
			});
			var characterskin =characterfolder.add(setting, 'CharacterSkin').options(character).onChange(function(val){
				characters[0].setSkin(character.indexOf(val));
			});
			
			
			characterfolder.open();
			
			

			var texture = ['brick_roughness.jpg','crate.gif','disturb.jpg','perlin-512.png','roughness_map.jpg',
				'square.png','tri_pattern.jpg','UV_Grid_Sm.jpg','waternormals.jpg' ,'waterdudv.jpg','water.jpg'
			];
			texturemap={FloorTexture:"waternormals.jpg", TextureRepeatU:15, TextureRepeatV:15};
			
			var texturefolder = gui.addFolder('Texture Folder');
			var texturedropdwon = texturefolder.add(texturemap, 'FloorTexture').options(texture);
			var texturerepeatU = texturefolder.add(texturemap,'TextureRepeatU',1,50);
			var texturerepeatV = texturefolder.add(texturemap,'TextureRepeatV',1,50);
			
			texturedropdwon.onChange(function(val){
				path = val;
				console.log(path);
				TextureChange();
			});
			
			texturerepeatU.onChange(function(val){
				u = val;
				console.log(u);
				TextureChange();
			});
			
			texturerepeatV.onChange(function(val){
				v = val;
				console.log(v);
				TextureChange();
			});

			texturefolder.open();
		}
		
		
		function TextureChange(){
			var tpath = "textures/" + path;
			textureLoader.load(tpath, function (texture) {
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(u, v);
			ground.material.map = texture;
			ground.material.needsUpdate = true;
			})
			console.log(tpath);
		};
			
	</script>

</body>

</html>
